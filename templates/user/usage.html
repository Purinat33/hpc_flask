{% extends "base.html" %}
{% block title %}My Usage{% endblock %}

{% block content %}
<h2>{{_("My Usage")}}</h2>
<p class="muted">{% trans user=current_user.username %}Signed in as <b>{{ user }}</b>{% endtrans %}</p>

<div class="card">
    <h3>Filter</h3>
    <form method="get" class="grid">
        <div>
            <label>Jobs completed before
                <input type="date" name="before" value="{{ before }}">
            </label>
        </div>
        <div><label>&nbsp;<button type="submit">Fetch</button></label></div>
    </form>

    {% if data_source %}
    <p class="muted">Source: <b>{{ data_source }}</b>{% if notes and notes|length>0 %} — {{ notes|join(' | ') }}{% endif
        %}</p>
    {% endif %}
</div>

<div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;">
        <h3>Your Jobs</h3>
        <div>
            <a href="{{ url_for('user.my_usage_csv', before=before) }}"><button type="button">Download CSV</button></a>
        </div>
    </div>

    <form method="post" action="{{ url_for('user.create_receipt') }}" style="display:inline">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <input type="hidden" name="before" value="{{ before }}">
        <button type="submit">{{ _("Create Receipt")}}</button>
    </form>

    <div class="tabs">
        <a class="{{ 'on' if view=='detail' else '' }}"
            href="{{ url_for('user.my_usage', before=before, view='detail') }}">Detailed</a>
        <a class="{{ 'on' if view=='aggregate' else '' }}"
            href="{{ url_for('user.my_usage', before=before, view='aggregate') }}">Aggregate</a>
    </div>

<style>
    /* Priority styles for header legend + raw-table header emphasis
     - primary:      bold + underline + italic
     - 1st fallback: bold + underline
     - 2nd fallback: bold + italic
  */
    .hl-primary {
        font-weight: 700;
        text-decoration: underline;
        font-style: italic;
    }

    .hl-fallback1 {
        font-weight: 700;
        text-decoration: underline;
    }

    .hl-fallback2 {
        font-weight: 700;
        font-style: italic;
    }

    .formula small {
        color: var(--muted, #666);
    }

    details.raw {
        margin-top: .75rem;
    }

    /* The wrapper is the scroll container (vertical + horizontal).
     Sticky headers will pin to the top INSIDE this element. */
    .table-wrap {
        position: relative;
        max-height: 60vh;
        /* vertical scroll */
        overflow: auto;
        /* both axes if needed */
        border: 1px solid var(--bd);
        border-radius: 10px;
    }

    /* Tables inside the wrapper behave like normal tables */
    .table-wrap>table {
        width: 100%;
        border: 0;
        /* wrapper holds the border */
        border-collapse: separate;
        border-spacing: 0;
        margin: 0;
    }

    /* Make header cells sticky within the scroll container */
    .table-wrap thead th {
        position: sticky;
        top: 0;
        z-index: 2;
        /* keep above body cells */
        background: #f8fafc;
        /* must have a background for sticky */
        box-shadow: 0 1px 0 var(--bd);
        /* subtle divider under the header */
    }

    /* Optional: freeze first column too (uncomment if you want this)
  .table-wrap tbody td:first-child,
  .table-wrap thead th:first-child {
    position: sticky;
    left: 0;
    z-index: 1;
    background: #ffffff;
    box-shadow: 1px 0 0 var(--bd);
  }
  .table-wrap thead th:first-child { z-index: 3; }  /* above the sticky row */
    */

    /* Don’t let long tokens blow up columns */
    .table-wrap th,
    .table-wrap td {
        overflow-wrap: anywhere;
    }

    .chip {
        display: inline-block;
        padding: .1rem .4rem;
        border-radius: .6rem;
        background: #efefef;
        margin-right: .25rem;
    }


    /* Footnotes / tooltips */
.formula abbr { text-decoration: none; border-bottom: 1px dotted var(--bd); cursor: help; }
.fn { font-size: .8em; margin-left: .25rem; color: var(--muted); text-decoration: none; }
details.footnotes { margin-top: .5rem; }
details.footnotes summary { cursor: pointer; color: #374151; font-weight: 600; }
.fn-list { margin: .25rem 0 0 1.25rem; }
.fn-list li { margin: .25rem 0; }
.fn-var { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

  details.collapsible {
    border: 1px solid var(--bd);
    border-radius: 10px;
    padding: .5rem .75rem;
    background: #fff;
    margin-top: 2rem;
  }
  details.collapsible > summary {
    list-style: none;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: baseline;
    gap: .25rem;
  }
  /* custom caret */
  details.collapsible > summary::before {
    content: "▸";
    display: inline-block;
    margin-right: .35rem;
    transform: translateY(-.05em);
  }
  details.collapsible[open] > summary::before {
    content: "▾";
  }
  .collapsible-body { margin-top: .5rem; }

</style>


    {% if view in ['detail','aggregate'] %}
    {% if data_source %}
    <p class="muted">Source: <b>{{ data_source }}</b>{% if notes and notes|length>0 %} — {{ notes|join(' | ') }}{% endif
        %}</p>
    {% endif %}

<!-- Formula legend with matching styles + tooltips + footnotes -->
<div class="formula" style="margin:.5rem 0 .25rem 0">
    <div>
        <b>CPU</b>:
        <span class="hl-primary">
            <abbr
                title="Total CPU time consumed per step (HH:MM:SS). We sum across all steps of the job and convert to hours.">Σ
                TotalCPU (steps)</abbr>
            <a href="#fn-totalcpu" class="fn">[1]</a>
        </span>
        <small>or</small>
        <span class="hl-fallback1">
            <abbr title="CPU time in seconds (integer). Divide by 3600 to get hours.">CPUTimeRAW / 3600</abbr>
            <a href="#fn-cputimeraw" class="fn">[2]</a>
        </span>
        <small>or</small>
        <span class="hl-fallback2">
            <abbr title="Allocated CPU cores from TRES × wall-clock runtime (hours).">AllocCPUS × Elapsed</abbr>
            <a href="#fn-alloccpus" class="fn">[3]</a><a href="#fn-elapsed" class="fn">[4]</a>
        </span>
    </div>

    <div>
        <b>MEM</b>:
        <span class="hl-primary">
            <abbr
                title="Average resident set size per step (converted to GB) × the step’s wall-clock hours, summed over steps.">Σ
                AveRSS(GB) × Elapsed (steps)</abbr>
            <a href="#fn-averss" class="fn">[5]</a><a href="#fn-elapsed" class="fn">[4]</a>
        </span>
        <small>or</small>
        <span class="hl-fallback2">
            <abbr title="Memory allocated (GB) parsed from TRES mem= × wall-clock hours.">Mem_from_TRES × Elapsed</abbr>
            <a href="#fn-memfromtres" class="fn">[6]</a><a href="#fn-elapsed" class="fn">[4]</a>
        </span>
    </div>

    <div>
        <b>GPU</b>:
        <span class="hl-primary">
            <abbr title="Number of GPUs allocated (from AllocTRES) × wall-clock hours.">AllocGPU × Elapsed</abbr>
            <a href="#fn-allocgpu" class="fn">[7]</a><a href="#fn-elapsed" class="fn">[4]</a>
        </span>
        <small>or</small>
        <span class="hl-fallback2">
            <abbr title="Requested GPUs (from ReqTRES) × wall-clock hours (fallback if AllocTRES lacks GPU).">ReqGPU ×
                Elapsed</abbr>
            <a href="#fn-reqgpu" class="fn">[8]</a><a href="#fn-elapsed" class="fn">[4]</a>
        </span>
    </div>
</div>

<!-- Footnotes / glossary -->
<details class="footnotes">
    <summary>What do these variables mean?</summary>
    <ol class="fn-list">
        <li id="fn-totalcpu"><span class="fn-var">TotalCPU</span> — Slurm field of CPU time used (HH:MM:SS[.fff]) per
            job/step. We sum over steps and convert to core-hours.</li>
        <li id="fn-cputimeraw"><span class="fn-var">CPUTimeRAW</span> — Slurm field of CPU time in seconds (integer). We
            divide by 3600 to get hours; used when <span class="fn-var">TotalCPU</span> is missing/zero.</li>
        <li id="fn-alloccpus"><span class="fn-var">AllocCPUS</span> — CPU cores allocated, parsed from <span
                class="fn-var">AllocTRES</span> (fallback <span class="fn-var">ReqTRES</span>) via <span
                class="fn-var">cpu=</span>.</li>
        <li id="fn-elapsed"><span class="fn-var">Elapsed</span> — Wall-clock runtime of the parent job (D-HH:MM:SS),
            converted to hours for calculations.</li>
        <li id="fn-averss"><span class="fn-var">AveRSS</span> — Average resident set size per step (K/M/G/T). We convert
            to GB; used to estimate memory actually used over time.</li>
        <li id="fn-memfromtres"><span class="fn-var">Mem_from_TRES</span> — Memory allocated (GB) parsed from <span
                class="fn-var">AllocTRES</span> (fallback <span class="fn-var">ReqTRES</span>) via <span
                class="fn-var">mem=</span>.</li>
        <li id="fn-allocgpu"><span class="fn-var">AllocGPU</span> — GPUs allocated parsed from <span
                class="fn-var">AllocTRES</span> via <span class="fn-var">gres/gpu=</span>.</li>
        <li id="fn-reqgpu"><span class="fn-var">ReqGPU</span> — GPUs requested parsed from <span
                class="fn-var">ReqTRES</span> via <span class="fn-var">gres/gpu=</span> (fallback only).</li>
    </ol>
    <div class="muted" style="margin-top:.25rem">
        Notes: “steps” means rows like <span class="fn-var">.batch</span>, <span class="fn-var">.0</span>, etc., which
        roll up to their parent job ID (or array task ID like <span class="fn-var">12345_17</span>). GPU is billed on
        allocation for now; memory prefers used (from <span class="fn-var">AveRSS</span>) and falls back to allocated.
    </div>
</details>

    {% endif %}

    {% if view == 'detail' %}
    {% if rows and rows|length>0 %}
    <p class="muted">
        <span class="chip">Jobs: {{ rows|length }}</span>
        <span class="chip">Total cost: ฿{{ '%.2f'|format(total_cost) }}</span>
    </p>
    <div class="table-wrap">
        <table>
            <thead>
                <tr>
                    <th>JobID</th>
                    <th>Elapsed</th>
                    <th>End</th>
                    <th>State</th>
                    <th>CPU core-hrs</th>
                    <th>GPU (count)</th>
                    <th>GPU hrs</th>
                    <th>Mem (GB alloc)</th>
                    <th>Mem GB-hrs <small>(used)</small></th>
                    <th>Mem GB-hrs <small>(alloc)</small></th>
                    <th>Tier</th>
                    <th>Cost (฿)</th>
                </tr>
            </thead>
            <tbody>
                {% for r in rows %}
                <tr>
                    <td>{{ r['JobID'] }}</td>
                    <td>{{ r['Elapsed'] }}</td>
                    <td>{{ r['End']|dt_local }}</td>
                    <td>{{ r['State'] }}</td>
                    <td>{{ '%.2f'|format(r['CPU_Core_Hours']) }}</td>
                    <td>{{ r['GPU_Count'] }}</td>
                    <td>{{ '%.2f'|format(r['GPU_Hours']) }}</td>
                    <td>{{ '%.2f'|format(r['Memory_GB']) }}</td>
                    <td>{{ '%.2f'|format(r['Mem_GB_Hours_Used']) }}</td>
                    <td>{{ '%.2f'|format(r['Mem_GB_Hours_Alloc']) }}</td>
                    <td>{{ r['tier']|upper }}</td>
                    <td>฿{{ '%.2f'|format(r['Cost (฿)']) }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    <!-- Collapsible: Raw fetched data -->
    <details class="raw">
        <summary>Show raw fetched data (parents + steps)</summary>
        {% if raw_cols and raw_rows %}
        <div class="table-wrap">
            <table>
                <thead>
                    <tr>
                        {% for c in raw_cols %}
                        <th class="{{ header_classes.get(c,'') }}">{{ c }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for r in raw_rows %}
                    <tr>
                        {% for c in raw_cols %}
                        <td>{{ r.get(c) }}</td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        <p class="muted" style="margin-top:.25rem">Showing first {{ raw_rows|length }} row(s).</p>
        {% else %}
        <p class="muted">No raw rows.</p>
        {% endif %}
    </details>

    {% else %}
    <p class="muted">No jobs for the selected period.</p>
    {% endif %}

    {% elif view == 'aggregate' %}
    {% if agg_rows and agg_rows|length>0 %}
    <table>
        <thead>
            <tr>
                <th>Jobs</th>
                <th>CPU core-hrs</th>
                <th>GPU hrs</th>
                <th>Mem GB-hrs (used)</th>
                <th>Total Cost (฿)</th>
            </tr>
        </thead>
        <tbody>
            {% for r in agg_rows %}
            <tr>
                <td>{{ r['jobs'] }}</td>
                <td>{{ '%.2f'|format(r['CPU_Core_Hours']) }}</td>
                <td>{{ '%.2f'|format(r['GPU_Hours']) }}</td>
                <td>{{ '%.2f'|format(r['Mem_GB_Hours_Used']) }}</td>
                <td>฿{{ '%.2f'|format(r['Cost (฿)']) }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <!-- optional: raw collapsible also for aggregate view -->
    <details class="raw">
        <summary>Show raw fetched data (parents + steps)</summary>
        {% if raw_cols and raw_rows %}
        <div class="table-wrap">
            <table>
                <thead>
                    <tr>
                        {% for c in raw_cols %}
                        <th class="{{ header_classes.get(c,'') }}">{{ c }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for r in raw_rows %}
                    <tr>
                        {% for c in raw_cols %}
                        <td>{{ r.get(c) }}</td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        <p class="muted" style="margin-top:.25rem">Showing first {{ raw_rows|length }} row(s).</p>
        {% else %}
        <p class="muted">No raw rows.</p>
        {% endif %}
    </details>

    {% else %}
    <p class="muted">No jobs for the selected period.</p>
    {% endif %}

    {% else %}
    <p class="muted">Unknown view.</p>
    {% endif %}
</div>
<details id="billing-transparency" class="collapsible">
    <summary>
        <h2 style="display:inline;">How We Compute Usage &amp; Billing</h2>
        <small class="muted" style="margin-left:.5rem;">(Transparency Note)</small>
    </summary>

    <div class="collapsible-body">
        <hr>
        <h3>Data Collection</h3>
        <ul>
            <li>We query <code>sacct</code> with: <code>--parsable2</code>, <code>-S</code> (start date), <code>-E</code>
                (end date), <code>-L</code>, and a fixed set of fields (see example below) [1].</li>
            <li>We include terminal states such as <code>COMPLETED</code>, <code>FAILED</code>, <code>CANCELLED</code>,
                <code>TIMEOUT</code>, <code>PREEMPTED</code>, <code>NODE_FAIL</code>, <code>BOOT_FAIL</code>,
                <code>DEADLINE</code> [1].
            </li>
            <li>If your account is permitted (per Slurm’s <code>PrivateData</code>/privacy configuration), we add
                <code>--allusers</code>; otherwise, we fetch only your own jobs [1],[2].
            </li>
        </ul>
        
        <h3>Fields We Use</h3>
        <p>We request and interpret the following Slurm fields:</p>
        <table class="table table-sm">
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Meaning (per Slurm)</th>
                    <th>How We Use It</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Elapsed</code></td>
                    <td>Wall-clock run time for the job/step, format <em>[days-]HH:MM:SS[.ms]</em> [1].</td>
                    <td>Converted to hours (<em>elapsed_h</em>). Used with allocated resources to infer time-based usage.
                    </td>
                </tr>
                <tr>
                    <td><code>TotalCPU</code></td>
                    <td>Sum of user+system CPU time across tasks for the job/step (may exceed elapsed due to parallelism)
                        [1].</td>
                    <td>Preferred CPU usage signal. We sum step <code>TotalCPU</code> (excluding the <code>.batch</code>
                        wrapper) when available.</td>
                </tr>
                <tr>
                    <td><code>CPUTime</code> / <code>CPUTimeRAW</code></td>
                    <td>CPU time in formatted/seconds form respectively [1].</td>
                    <td>Fallback for CPU usage when <code>TotalCPU</code> is missing or zero (we use
                        <code>CPUTimeRAW/3600</code>).
                    </td>
                </tr>
                <tr>
                    <td><code>ReqTRES</code>, <code>AllocTRES</code></td>
                    <td>Requested/allocated Trackable RESources (e.g., <code>cpu=</code>, <code>mem=</code>,
                        <code>gres/gpu=</code>) [3].
                    </td>
                    <td>Used to obtain CPU count, GPU count, and memory capacity for allocation-based calculations and
                        fallbacks.</td>
                </tr>
                <tr>
                    <td><code>AveRSS</code>, <code>MaxRSS</code></td>
                    <td>Average / maximum resident set size (per step/job aggregation) [1].</td>
                    <td><code>AveRSS</code> per step × step elapsed gives “used memory GB-hours”. If unavailable, we fall
                        back to allocated memory.</td>
                </tr>
                <tr>
                    <td>Meta: <code>User</code>, <code>JobID</code>, <code>JobName</code>, <code>End</code>,
                        <code>State</code>, <code>ExitCode</code>, <code>NodeList</code>, <code>AllocNodes</code>
                    </td>
                    <td>Identification, status, and auditability fields [1],[4].</td>
                    <td>Used for grouping parent/steps, filtering, and traceability (not priced directly).</td>
                </tr>
            </tbody>
        </table>
        
        <h3>Billing Formula</h3>
        <p>The per-job (parent) cost is computed as:</p>
        <pre><code>Cost = (CPU_core_hours × cpu_rate)
             + (GPU_hours × gpu_rate)
             + (Memory_GB_hours_used × mem_rate)</code></pre>
        <ul>
            <li><strong>CPU_core_hours</strong>:
                <ul>
                    <li>Primary: sum of <code>TotalCPU</code> (hours) over job steps (excluding <code>.batch</code>).</li>
                    <li>Fallbacks: sum of <code>CPUTimeRAW</code> over steps; else parent <code>TotalCPU</code>; else
                        <code>AllocCPUS × elapsed_h</code>.
                    </li>
                </ul>
            </li>
            <li><strong>GPU_hours</strong>: <code>(GPU count from AllocTRES or ReqTRES) × elapsed_h</code>.</li>
            <li><strong>Memory_GB_hours_used</strong>:
                <ul>
                    <li>Primary: sum over steps of <code>AveRSS(GB) × step_elapsed_h</code>.</li>
                    <li>Fallback: <code>(allocated memory GB) × elapsed_h</code>.</li>
                </ul>
            </li>
            <li>Rates (<code>cpu_rate</code>, <code>gpu_rate</code>, <code>mem_rate</code>) are published per tier and
                versioned in this service.</li>
        </ul>
        
        <h3>FAQ</h3>
        <dl>
            <dt>Why are some values zero?</dt>
            <dd>
                If <code>TotalCPU</code> and <code>CPUTimeRAW</code> are not reported for steps and allocations are also
                unavailable,
                CPU may evaluate to 0 until a fallback applies. Similarly, if <code>AveRSS</code> is missing and no
                <code>mem=</code> is present in TRES, memory usage may appear as 0. See field fallbacks above [1],[3].
            </dd>
        
            <dt>What are job “steps” and why do they matter?</dt>
            <dd>
                Slurm records a parent job row plus one or more step rows (e.g., <code>12345.batch</code>,
                <code>12345.0</code>, <code>12345.1</code>).
                We group steps under their parent and aggregate usage so the parent’s cost includes all step activity
                [1],[4].
            </dd>
        
            <dt>Why exclude <code>.batch</code> from CPU sums?</dt>
            <dd>
                The <code>.batch</code> step is a wrapper and can duplicate accounting; excluding it avoids double counting.
                This is a common operational choice informed by how Slurm reports step accounting [1].
            </dd>
        
            <dt>Why can CPU usage exceed elapsed time?</dt>
            <dd>
                <code>TotalCPU</code> represents cumulative CPU time across concurrent tasks; in parallel workloads it can
                exceed wall-clock elapsed (that is expected) [1].
            </dd>
        
            <dt>What about time zones and date filters?</dt>
            <dd>
                <code>End</code> timestamps are interpreted in the cluster’s local time. The requested end date includes
                jobs finishing on that date (up to 23:59:59) [1],[2].
            </dd>
        </dl>
        
        <h3>Worked Example (Made-Up Numbers)</h3>
        <p>Below is an illustrative <code>sacct</code>-style extract (pipe-delimited). Values are intentionally simple for
            clarity.</p>
        {% set example_raw %}
        User|JobID|JobName|Elapsed|TotalCPU|CPUTime|CPUTimeRAW|ReqTRES|AllocTRES|AveRSS|MaxRSS|TRESUsageInTot|TRESUsageOutTot|End|State|ExitCode|DerivedExitCode|ConsumedEnergyRaw|ConsumedEnergy|NodeList|AllocNodes
        alice|1001|train|02:01:00|00:00:00|0000:00:00|0|cpu=4,mem=8G,gres/gpu=1|cpu=4,mem=8G,gres/gpu=1|||||2025-09-20T12:00:00|COMPLETED|0:0|0:0|||node01|1
        |1001.batch|batch|02:01:00|00:00:10|0000:00:00|0||cpu=4,gres/gpu=1,mem=0,node=1|0K|0K||||COMPLETED|0:0|0:0|||node01|1
        |1001.0|step0|01:00:00|25:00:00|0000:00:00|0||cpu=4,gres/gpu=1,mem=0,node=1|4G|4G||||COMPLETED|0:0|0:0|||node01|1
        |1001.1|step1|01:01:00|25:00:00|0000:00:00|0||cpu=4,gres/gpu=1,mem=0,node=1|4G|4G||||COMPLETED|0:0|0:0|||node01|1
        {% endset %}
        
        {% set lines = example_raw.strip().splitlines() %}
        {% set rows = [] %}
        {% for line in lines %}
        {% set _ = rows.append(line.split('|')) %}
        {% endfor %}
        {% set header = rows[0] %}
        {% set body = rows[1:] %}
        
        <details class="raw">
            <summary>Show example raw output as a table</summary>
            <div class="table-wrap" style="margin-top:.5rem;">
                <table>
                    <thead>
                        <tr>
                            {% for h in header %}
                            <th>{{ h }}</th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for r in body %}
                        <tr>
                            {% for cell in r %}
                            <td>{{ cell }}</td>
                            {% endfor %}
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </details>

        
        <p><strong>Rates (example):</strong> <code>cpu_rate = ฿1 / core-hour</code>, <code>gpu_rate = ฿5 / GPU-hour</code>,
            <code>mem_rate = ฿0.50 / GB-hour</code>.
        </p>
        <ol>
            <li><strong>Elapsed (parent)</strong>: <code>02:01:00</code> = 2&nbsp;h&nbsp;1&nbsp;m &rarr; <em>elapsed_h</em>
                = 2.0167&nbsp;h.</li>
            <li><strong>CPU_core_hours</strong>: sum step <code>TotalCPU</code> (exclude <code>.batch</code>):
                <code>25:00:00</code> + <code>25:00:00</code> = 50&nbsp;h.
            </li>
            <li><strong>GPU_hours</strong>: <code>gres/gpu=1</code> × 2.0167&nbsp;h = 2.0167&nbsp;GPU-h.</li>
            <li><strong>Memory_GB_hours_used</strong>: steps’ <code>AveRSS</code> 4&nbsp;GB each:
                <ul>
                    <li>Step0: 4&nbsp;GB × 1.00&nbsp;h = 4&nbsp;GB-h</li>
                    <li>Step1: 4&nbsp;GB × 1.0167&nbsp;h ≈ 4.0668&nbsp;GB-h</li>
                    <li>Total ≈ 8.0668&nbsp;GB-h (fallback would be 8&nbsp;GB × 2.0167&nbsp;h ≈ 16.1336&nbsp;GB-h if AveRSS
                        were missing)</li>
                </ul>
            </li>
        </ol>
        
        <p><strong>Cost:</strong></p>
        <pre><code>CPU: 50.0000 × 1      = ฿50.00
        GPU: 2.0167 × 5        = ฿10.08
        MEM: 8.0668 × 0.50     = ฿4.03
        -----------------------------
        Total                  ≈ ฿64.11
        </code></pre>
            <h3>References</h3>
            <ol>
                <li><a href="https://slurm.schedmd.com/sacct.html" rel="noopener noreferrer">Slurm sacct(1) — command, fields,
                        formats, filters</a></li>
                <li><a href="https://slurm.schedmd.com/accounting.html" rel="noopener noreferrer">Slurm Accounting —
                        configuration, privacy (<code>PrivateData</code>), usage</a></li>
                <li><a href="https://slurm.schedmd.com/tres.html" rel="noopener noreferrer">Trackable RESources (TRES) — CPU,
                        memory, GPUs</a></li>
                <li><a href="https://slurm.schedmd.com/sacct.html#SECTION_OUTPUT-FIELDS" rel="noopener noreferrer">sacct Output
                        Fields — definitions for <code>TotalCPU</code>, <code>AveRSS</code>, etc.</a></li>
                <li><a href="https://slurm.schedmd.com/" rel="noopener noreferrer">Slurm Official Documentation Home</a></li>
            </ol>
            <!-- === your existing section content ends here === -->
            </div>
            </details>
{% endblock %}
